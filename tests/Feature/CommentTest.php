<?php

namespace Tests\Feature;

use App\Models\Comment;
use App\Models\Post;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Http\Response;
use Symfony\Component\HttpFoundation\Response as ResponseAlias;
use Tests\TestCase;

class CommentTest extends TestCase
{
    use RefreshDatabase, WithFaker;

    /**
     * @return void
     */
    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->user         = User::factory()->create();
        $this->otherUser =  User::factory()->create();
    }

    public function test_can_add_comment_to_post() :void
    {
        $response = $this
            ->actingAs($this->user)
            ->get('/profile');
        $response->assertOk();

        $post = $this->user->posts()->create([
            'title' => $this->faker->sentence(5),
        ]);

        $attributes = [
            'body'                      =>  $this->faker->sentence(7),
            'commentable_type'   =>  Post::class,
            'commentable_id'       =>  null,
        ];

        // check authorization
        $response = $this
                    ->actingAs($this->user)
                     ->post('/comments', $attributes);
        $response
            ->assertSessionHasErrors('commentable_id');

        // should be work!
        $attributes['commentable_id'] = $post->id;
        $response = $this->actingAs($this->user)
                                ->post('/comments', $attributes);
        $response->assertSessionDoesntHaveErrors();
    }

    public function test_can_reply_a_comment() :void
    {
        $post = $this->user->posts()->create([
            'title' => $this->faker->sentence(7),
        ]);

        // should be SUCCESSFUL
        $createdComment = Comment::factory()->create([
            'user_id'                   => $this->user->id,
            'body'                      =>  $this->faker->sentence(20),
            'commentable_type'   =>  Post::class,
            'commentable_id'       =>  $post->id,
        ]);
        $this->assertDatabaseHas('comments', ['id' => $createdComment->id, 'user_id' => $this->user->id]);

        $request = [
            'body'                      =>  $this->faker->sentence(20),
            'parent_id'                =>  $createdComment->id,
            'commentable_id'       =>  $post->id,
        ];

        // check validation
        $response = $this
            ->actingAs($this->user)
                                ->post('/comments', $request);
        $response->assertSessionHasErrors('commentable_type');

        // should be work
        $request['commentable_type'] = Post::class;
        $response = $this->actingAs($this->user)
            ->post('/comments', $request);
        $response->assertSessionDoesntHaveErrors();
    }

    public function test_can_update_comment() :void
    {
        $user = User::factory()->create();
        $post = $user->posts()->create([
            'title' => $this->faker->sentence(7),
        ]);

        // should be SUCCESSFUL
        $createdComment = Comment::factory()->create([
            'user_id'                   => $user->id,
            'body'                      => 'test comment created',
            'commentable_type'   =>  Post::class,
            'commentable_id'       =>  $post->id,
        ]);
        $this->assertDatabaseHas('comments', ['id' => $createdComment->id, 'user_id' => $user->id]);

        $request = [
            'body'  => 'test comment updated',
        ];

        $response = $this->actingAs($user)
            ->put("/comments/{$createdComment->id}", $request);

        $response->assertSessionDoesntHaveErrors();
        $response->assertStatus(ResponseAlias::HTTP_FOUND);
    }

    public function test_can_delete_reply_comment() :void
    {
        $post = $this->user->posts()->create([
            'title' => $this->faker->sentence(7),
        ]);

        // should be SUCCESSFUL
        $createdComment = Comment::factory()->create([
            'user_id'                   => $this->user->id,
            'body'                      =>  $this->faker->sentence(),
            'commentable_type'   =>  Post::class,
            'commentable_id'       =>  $post->id,
        ]);
        $this->assertDatabaseHas('comments', ['id' => $createdComment->id, 'user_id' => $this->user->id]);

        $data = [
            'user_id'                   => $this->user->id,
            'parent_id'                => $createdComment->id,
            'body'                      =>  $this->faker->sentence(8),
            'commentable_type'   => Post::class,
            'commentable_id'       =>  $post->id,
        ];

        $createdReplayComment = Comment::factory()->create($data);
        $this->assertDatabaseHas('comments', ['id' => $createdReplayComment->id, 'user_id' => $this->user->id]);

        $response = $this->actingAs($this->user)
            ->delete("/comments/{$createdReplayComment->id}");

        $response->assertSessionDoesntHaveErrors();
        $this->assertDatabaseMissing('comments', $data);
    }

    public function test_can_other_user_update_a_comment_that_doesnt_belong_to_it() :void
    {
        $post = $this->user->posts()->create([
            'title' => $this->faker->sentence(7),
        ]);
        $this->assertTrue(true);
        $data = [
            'user_id'                   => $this->user->id,
            'body'                      =>  $this->faker->sentence(8),
            'commentable_type'   => Post::class,
            'commentable_id'       =>  $post->id,
        ];

        $createdComment = Comment::factory()->create($data);
        $this->assertDatabaseHas('comments', ['id' => $createdComment->id, 'user_id' => $this->user->id]);

        $request = [
            'body' => 'test comment updated',
        ];

        // If they are not authorized, it will return a 403 Forbidden response.
        $response = $this->actingAs($this->otherUser)
            ->put("/comments/{$createdComment->id}", $request);

        $response->assertStatus(Response::HTTP_FORBIDDEN);
    }
}
